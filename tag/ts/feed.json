{
    "version": "https://jsonfeed.org/version/1",
    "title": "star belog • All posts by \"ts\" tag",
    "description": "",
    "home_page_url": "https://zhixin-zou.github.io",
    "items": [
        {
            "id": "https://zhixin-zou.github.io/2022/11/17/typeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ts%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E3%80%81%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B/",
            "url": "https://zhixin-zou.github.io/2022/11/17/typeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ts%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E3%80%81%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B/",
            "title": "ts类型推论、联合类型",
            "date_published": "2022-11-17T06:51:32.056Z",
            "content_html": "<h1 id=\"ts类型推论-联合类型\"><a class=\"anchor\" href=\"#ts类型推论-联合类型\">#</a> ts 类型推论、联合类型</h1>\n<h2 id=\"ts类型推论\"><a class=\"anchor\" href=\"#ts类型推论\">#</a> ts 类型推论</h2>\n<p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let stringType = &#x27;test&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">stringType = &#x27;teststring&#x27;     // 编译通过</span><br><span class=\"line\">stringType = 1                // 编译报错</span><br></pre></td></tr></table></figure><br>\n 其实上述代码等价于<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let stringType: string = &#x27;test&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">stringType = &#x27;teststring&#x27;     // 编译通过</span><br><span class=\"line\">stringType = 1                // 编译报错</span><br></pre></td></tr></table></figure><br>\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>\n<p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let anyType;</span><br><span class=\"line\">anyType = &#x27;teststring&#x27;;</span><br><span class=\"line\">anyType = 1;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"联合类型\"><a class=\"anchor\" href=\"#联合类型\">#</a> 联合类型</h2>\n<p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let numberString: number | string</span><br><span class=\"line\"></span><br><span class=\"line\">numberString = 1           // 编译成功</span><br><span class=\"line\">numberString = &#x27;1&#x27;         // 编译成功</span><br><span class=\"line\">numberString = true        // 报错</span><br></pre></td></tr></table></figure><br>\n 联合类型使用 | 分隔每个类型，可以将 | 理解为或.</p>\n<h5 id=\"访问联类型的属性和方法\"><a class=\"anchor\" href=\"#访问联类型的属性和方法\">#</a> 访问联类型的属性和方法</h5>\n<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getLength(something: string): number &#123;</span><br><span class=\"line\">    return something.length; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getLength2(something: string | number): number &#123;</span><br><span class=\"line\">    return something.length;      //  报错</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getString(something: string | number): string &#123;</span><br><span class=\"line\">    return something.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>\n 对比上面三个函数<br>\n length 是 string 的属性<br>\n length 不是 string 和 number 的共有属性，所以 getLength2 会报错。<br>\n访问 string 和 number 的共有属性是没问题的 getString 即可编译通过。</p>\n",
            "tags": [
                "ts"
            ]
        },
        {
            "id": "https://zhixin-zou.github.io/2022/11/14/typeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typeScript%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/",
            "url": "https://zhixin-zou.github.io/2022/11/14/typeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typeScript%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/",
            "title": "typeScript基础类型",
            "date_published": "2022-11-14T09:35:28.487Z",
            "content_html": "<h2 id=\"typescript基础类型\"><a class=\"anchor\" href=\"#typescript基础类型\">#</a> TypeScript 基础类型</h2>\n<h3 id=\"1数字类型\"><a class=\"anchor\" href=\"#1数字类型\">#</a> 1. 数字类型</h3>\n<p>在 typescript 里所有数字都是浮点型，除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a: Number</span><br><span class=\"line\">a = 1</span><br><span class=\"line\"></span><br><span class=\"line\">let b: Number = 0xd000</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2字符类型\"><a class=\"anchor\" href=\"#2字符类型\">#</a> 2. 字符类型</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str1: string = &#x27;123&#x27;;</span><br><span class=\"line\">let str2: string = &#x27;456&#x27;;</span><br><span class=\"line\">console.log(str1 + &#x27;,&#x27; + str2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3布尔类型\"><a class=\"anchor\" href=\"#3布尔类型\">#</a> 3. 布尔类型</h3>\n<p>表示逻辑值：true 和 false。<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let flag: boolean = true</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4数组类型\"><a class=\"anchor\" href=\"#4数组类型\">#</a> 4. 数组类型</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在元素类型后面加上[],前面number表示数组中元素类型</span><br><span class=\"line\">let arr: number[] = [1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者使用数组泛型</span><br><span class=\"line\">let arr1: Array&lt;number&gt; = [1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">let arr2: String[] = [&#x27;1&#x27;, &#x27;1&#x27;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5元组\"><a class=\"anchor\" href=\"#5元组\">#</a> 5. 元组</h3>\n<p>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x: [string, number];</span><br><span class=\"line\">x = [&#x27;one&#x27;, 1];    // 运行正常</span><br><span class=\"line\">// x = [1, &#x27;one&#x27;];    // 报错</span><br><span class=\"line\">x = [&#x27;two&#x27;, 2]</span><br><span class=\"line\">console.log(x[0]);    // two</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"6枚举\"><a class=\"anchor\" href=\"#6枚举\">#</a> 6. 枚举</h3>\n<p>枚举类型用于定义数值集合。<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;</span><br><span class=\"line\">    red,</span><br><span class=\"line\">    green,</span><br><span class=\"line\">    blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 定义一个Color的枚举类型的变量来接收枚举的值</span><br><span class=\"line\">let color: Color = Color.red</span><br><span class=\"line\">console.log(color);</span><br><span class=\"line\">console.log(Color[2])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"7void\"><a class=\"anchor\" href=\"#7void\">#</a> 7.void</h3>\n<p>在一定程度上 void 和 any 的类型像是相反的，表示没有任何类型，当一个函数没有返回值时，通常会见到其返回值类型是 void；<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(str):void&#123;</span><br><span class=\"line\">console.log(&quot;this is my book&quot;)    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 声明一个 void 类型变量似乎没什么大用，因为只能为他赋予 undefined 和 null</p>\n<h3 id=\"8null\"><a class=\"anchor\" href=\"#8null\">#</a> 8.null</h3>\n<p>①TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大；</p>\n<p>②默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。</p>\n<h3 id=\"9undefined\"><a class=\"anchor\" href=\"#9undefined\">#</a> 9.undefined</h3>\n<h3 id=\"10never\"><a class=\"anchor\" href=\"#10never\">#</a> 10.never</h3>\n<p>①never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。</p>\n<p>②never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x: never;</span><br><span class=\"line\">let y: number;</span><br><span class=\"line\"></span><br><span class=\"line\">// 编译错误，数字类型不能转为 never 类型</span><br><span class=\"line\">x = 123;</span><br><span class=\"line\"></span><br><span class=\"line\">// 运行正确，never 类型可以赋值给 never类型</span><br><span class=\"line\">x = (()=&gt;&#123; throw new Error(&#x27;exception&#x27;)&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">// 运行正确，never 类型可以赋值给 数字类型</span><br><span class=\"line\">y = (()=&gt;&#123; throw new Error(&#x27;exception&#x27;)&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回值为 never 的函数可以是抛出异常的情况</span><br><span class=\"line\">function error(message: string): never &#123;</span><br><span class=\"line\">    throw new Error(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span><br><span class=\"line\">function loop(): never &#123;</span><br><span class=\"line\">    while (true) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"11any\"><a class=\"anchor\" href=\"#11any\">#</a> 11.any</h3>\n<p>任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p>\n<p>1、变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查，示例代码如下：<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x: any = 1;    // 数字类型</span><br><span class=\"line\">x = &#x27;I am who I am&#x27;;    // 字符串类型</span><br><span class=\"line\">x = false;    // 布尔类型</span><br></pre></td></tr></table></figure><br>\n 改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查，示例代码如下：<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x: any = 4;</span><br><span class=\"line\">x.ifItExists();    // 正确，ifItExists方法在运行时可能存在，但这里并不会检查</span><br><span class=\"line\">x.toFixed();    // 正确</span><br></pre></td></tr></table></figure><br>\n 定义存储各种类型数据的数组时，示例代码如下：<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arrayList: any[] = [1, false, &#x27;fine&#x27;];</span><br><span class=\"line\">arrayList[1] = 100;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"12-object\"><a class=\"anchor\" href=\"#12-object\">#</a> 12 object</h3>\n<p>对象类型，非原始类型，常见的形式通过 {} 进行包裹<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj:object;</span><br><span class=\"line\">obj = &#123;name: &#x27;Zhangsan&#x27;, age: 25&#125;;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "ts"
            ]
        }
    ]
}